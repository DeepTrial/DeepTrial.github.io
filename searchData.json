[{"title":"Leetcode#354 俄罗斯套娃信封问题","url":"/2020/02/17/leetcode-354/","content":"\n# 354 俄罗斯套娃信封问题\n\n## 题目描述\n\n给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。\n\n请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。\n\n说明:\n不允许旋转信封。\n\n示例:\n\n>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n>\n>输出: 3 \n>\n>解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。\n\n## 分析\n这是一道典型的动态规划题目，假设信封大小（w，h），因为不能旋转，所以只需w之间比较，h之间比较。若我们先按照w递增的顺序排列，再从h的序列中寻找最长上升子序列，则此序列长度就是答案。可以看出，我们将这个问题转换成为了求最长上升子序列的问题。\n\n## 代码\n```\nclass Solution {\npublic:\n    static bool cmpEnvelope(vector<int> &a, vector<int> &b) {\n        if(a[0] != b[0]) {\n            return a[0] < b[0];\n        } else if (a[1] != b[1]) {\n            return a[1] > b[1];\n        }\n        return 0;\n    }\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\n        // 先排序\n        int size = envelopes.size();\n        if (size <= 1) {\n            return size;\n        }\n        sort(envelopes.begin(), envelopes.end(), cmpEnvelope);\n        vector<int> dp(size, 1);\n        int maxEnv = 1;\n        for (int k = 0; k < size; ++k) {\n            for (int i = 0; i < k; ++i) {\n                if (envelopes[k][1] > envelopes[i][1]) {\n                    dp[k] = max(dp[k], dp[i] + 1);\n                }\n            }\n            if (dp[k] > maxEnv) {\n                maxEnv = dp[k];\n            }\n        }\n        return maxEnv;\n    }\n\n};\n```","tags":["leetcode"]},{"title":"Leetcode#143 环状链表II","url":"/2020/02/13/leetcode-143/","content":"\n# 143 环状链表II\n\n## 题目描述\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n示例1:\n\n>输入：head = [3,2,0,-4], pos = 1\n>\n>输出：tail connects to node index 1\n>\n>解释：链表中有一个环，其尾部连接到第二个节点。\n\n![avatar](./1.jpg)\n\n示例 2：\n\n>输入：head = [1,2], pos = 0\n>\n>输出：tail connects to node index 0\n>\n>解释：链表中有一个环，其尾部连接到第一个节点。\n\n![avatar](./2.jpg)\n\n示例 3：\n\n>输入：head = [1], pos = -1\n>\n>输出：no cycle\n>\n>解释：链表中没有环。\n\n![avatar](./3.jpg)\n\n\n## 分析\n\n利用快慢指针来解这道题，快指针的速度为2，慢指针的速度为1.\n\n在示例1中，快慢指针第一次在-4点相遇，快指针走的路径6是慢指针3的二倍，即长度3->2->0->-4->2->0->-4是长度3-2-0->-4的二倍，也就是说-4->2->0->-4的长度（即一圈的长度）等于3-2-0->-4的长度，将两个长度同时减掉2-0->-4，则-4->2的长度等于3->2的长度。\n\n所以在第一次相遇后，我们只需要将慢指针的起点指定为head的起点，快指针的位置不变(-4)，并且将快慢指针的速度都设置为1，那么下次相遇的点就是圆环的起点（2）。\n\n## 代码\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow=head,*fast=head;\n        while(fast&&fast->next)\n        {\n            slow=slow->next;\n            fast=fast->next->next;\n            if(slow==fast) break;\n        }\n        if(!fast||!fast->next) return NULL;\n        slow=head;\n        while(fast!=slow)\n        {\n            slow=slow->next;\n            fast=fast->next;\n        }\n        return slow;\n    }\n};\n```","tags":["leetcode"],"categories":["leetcode"]},{"title":"Leetcode#15 三数之和","url":"/2020/02/06/leetcode-15/","content":"\n# 15.三数之和\n\n## 题目\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n示例：\n```\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n## 题解\n这题最大的问题是容易超时。显而易见的解法是利用三重循环枚举所有位置，并利用hash表等判断是否有重复，但不幸的是这个方法会遇到超时问题。\n\n重新分析问题，若三数之和为0，即a+b+c=0，则必有大于0和小于0的数字。由此可见一种可行的方法是：\n- 从小到大排数数组\n- 指针i枚举所有小于0的数，并且该数之前没出现过\n- 指针left从i+1开始递增，指针right从数组末尾开始递减，当两者重合时结束当前i位置的搜索\n    - 判断i,left,right位置的和是否为0，如果大于0，则right位置减1，否则left位置加1\n\n代码如下：\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) \n    {\n        vector<vector<int>> result;\n        int left,right;\n        if(nums.empty() || nums.size()<2)\n            return result;\n\n        sort(nums.begin(),nums.end());\n        \n        \n        for(int i=0;i<nums.size()-2;i++)\n        {\n            if(nums[i]>0)\n                break;\n            if(i>0 && nums[i-1]==nums[i])\n                continue;\n            left=i+1;\n            right=nums.size()-1;\n            while(left<right)\n            {\n                if(nums[i]+nums[left]+nums[right]==0)\n                {\n                    result.push_back({nums[i],nums[left],nums[right]});\n                    while(left<right && nums[left]==nums[left+1])\n                        left++;\n                    while(left<right && nums[right]==nums[right-1])\n                        right--;\n                    left++;\n                    right--;\n                }\n                else\n                {\n                    if(nums[left]+nums[right]+nums[i]<0)\n                        left++;\n                    else\n                        right--;\n                }\n            }\n        }\n        return result;\n    }\n};\n```","tags":["leetcode"],"categories":["leetcode"]},{"title":"Leetcode#3 无重复字符的最长子串","url":"/2020/02/02/leetcode-3/","content":"\n\n# 3.无重复字符的最长子串\n\n## 题目\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n示例 2:\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n示例 3:\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n\n## 题解\n\n用时：4ms\n[start,end-1]的滑窗是检测的子串，每次将end指向的字符加入字串，并判断有无重复，若有重复的，则将start移动到重复字符后一位。\n```\nclass Solution {\npublic:\n    \n    int lengthOfLongestSubstring(string s) {\n        vector<int> mask(128,-1);    //存储字符出现的位置\n        int start=-1,maxLength=0;\n        \n        for(int end=0;end<s.size();end++)\n        {\n            if(mask[s[end]]>=start)    //end端新加入的字符在[start，end-1]出现过\n            {\n                start=mask[s[end]]+1;  //将起始端跳转到重复字符后一位\n            }\n            mask[s[end]]=end;  \n            maxLength=max(maxLength,end-start+1);\n        }\n        return maxLength;\n    }\n};\n```","tags":["leetcode"],"categories":["leetcode"]},{"title":"深度学习中的图像分割算法综述","url":"/2020/01/20/segmentation-survey/","content":"\n{% pdf ./segmentation.pdf %} ","tags":["深度学习","segmentation"],"categories":["课件分享"]},{"title":"Annotation-Free and One-Shot Learning for Instance Segmentation of Homogeneous Object Clusters","url":"/2020/01/20/HOC/","content":"\nIJCAI 2018 论文解析\n\n2018年秋季学期知识处理讨论班课件\n\n{% pdf ./HOC-Segmentation.pdf %} ","tags":["instance segmentation","IJCAI"],"categories":["课件分享"]},{"title":"C++手册","url":"/2020/01/20/Cpp-plus/","content":"\n# C++学习手册\n\n## define\n定义宏，例如：\n`#define MAX(x,y) (((x)>(y))?(x):(y))`\n\n\n这个宏定义了一个求最大值的函数MAX\n\n## ifdef\n如果宏已经定义，则编译下方代码\n\n## ifndef\n如果宏没有定义，则编译下方代码\n\n## endif\nendif 结束一个 #if...#else...代码块\n\n## virtual 虚函数\n[https://www.cnblogs.com/jianyungsun/p/6361670.html][1]\n虚函数常在工程中作为接口使用\n\n\n[1]: https://www.cnblogs.com/jianyungsun/p/6361670.html\n\n","tags":["c++"],"categories":["开发语言"]},{"title":"Git使用手册","url":"/2020/01/20/git/","content":"\n## 常用命令\n\n| 功能                      | 命令                                  |\n|:--------------------------|:--------------------------------------|\n| 添加文件/更改到暂存区     | git add filename                      |\n| 添加所有文件/更改到暂存区 | git add .                             |\n| 提交                      | git commit -m msg                     |\n| 从远程仓库拉取最新代码    | git pull origin master                |\n| 推送到远程仓库            | git push origin master                |\n| 查看配置信息              | git config --list                     |\n| 查看文件列表              | git ls-files                          |\n| 比较工作区和暂存区        | git diff                              |\n| 比较暂存区和版本库        | git diff --cached                     |\n| 比较工作区和版本库        | git diff HEAD                         |\n| 从暂存区移除文件          | git reset HEAD filename               |\n| 查看本地远程仓库配置      | git remote -v                         |\n| 回滚                      | git reset --hard 提交SHA              |\n| 强制推送到远程仓库        | git push -f origin master             |\n| 修改上次 commit           | git commit --amend                    |\n| 推送 tags 到远程仓库      | git push --tags                       |\n| 推送单个 tag 到远程仓库   | git push origin [tagname]             |\n| 删除远程分支              | git push origin --delete [branchName] |\n| 远程空分支（等同于删除）  | git push origin :[branchName]         |\n| 查看所有分支历史          | gitk --all                            |\n| 按日期排序显示历史        | gitk --date-order                     |\n\n## Q&A\n\n### 如何解决gitk中文乱码，git ls-files 中文文件名乱码问题？\n\n在~/.gitconfig中添加如下内容\n\n```\n[core]\n   quotepath = false\n[gui]\n   encoding = utf-8\n[i18n]\n   commitencoding = utf-8\n[svn]\n   pathnameencoding = utf-8\n```\n\n参考 <http://zengrong.net/post/1249.htm>\n\n### 如何处理本地有更改需要从服务器合入新代码的情况？\n\n```\ngit stash\ngit pull\ngit stash pop\n```\n\n### stash\n\n查看 stash 列表：\n\n```\ngit stash list\n```\n\n查看某一次 stash 的改动文件列表（不传最后一个参数默认显示最近一次）：\n\n```\ngit stash show stash@{0}\n```\n\n以 patch 方式显示改动内容\n\n```\ngit stash show -p stash@{0}\n```\n\n### 如何合并 fork 的仓库的上游更新？\n\n```\ngit remote add upstream https://upstream-repo-url\ngit fetch upstream\ngit merge upstream/master\n```\n\n### 如何通过 TortoiseSVN 带的 TortoiseMerge.exe 处理 git 产生的 conflict？\n* 将 TortoiseMerge.exe 所在路径添加到 `path` 环境变量。\n* 运行命令 `git config --global merge.tool tortoisemerge` 将 TortoiseMerge.exe 设置为默认的 merge tool。\n* 在产生 conflict 的目录运行 `git mergetool`，TortoiseMerge.exe 会跳出来供你 resolve conflict。\n\n  > 也可以运行 `git mergetool -t vimdiff` 使用 `-t` 参数临时指定一个想要使用的 merge tool。\n\n### 不想跟踪的文件已经被提交了，如何不再跟踪而保留本地文件？\n\n`git rm --cached /path/to/file`，然后正常 add 和 commit 即可。\n\n### 如何不建立一个没有 parent 的 branch？\n\n```\ngit checkout --orphan newbranch\n```\n\n此时 `git branch` 是不会显示该 branch 的，直到你做完更改首次 commit。比如你可能会想建立一个空的 gh-pages branch，那么：\n\n```\ngit checkout --orphan gh-pages\ngit rm -rf .\n// add your gh-pages branch files\ngit add .\ngit commit -m \"init commit\"\n```\n\n### submodule 的常用命令\n\n**添加 submodule**\n\n```\ngit submodule add git@github.com:philsquared/Catch.git Catch\n```\n\n这会在仓库根目录下生成如下 .gitmodules 文件并 clone 该 submodule 到本地。\n\n```\n[submodule \"Catch\"]\npath = Catch\nurl = git@github.com:philsquared/Catch.git\n```\n\n**更新 submodule**\n\n```\ngit submodule update\n```\n\n当 submodule 的 remote 有更新的时候，需要\n\n```\ngit submodule update --remote\n```\n\n**删除 submodule**\n\n在 .gitmodules 中删除对应 submodule 的信息，然后使用如下命令删除子模块所有文件：\n\n```\ngit rm --cached Catch\n```\n\n**clone 仓库时拉取 submodule**\n\n```\ngit submodule update --init --recursive\n```\n\n### 删除远程 tag\n\n```\ngit tag -d v0.0.9\ngit push origin :refs/tags/v0.0.9\n```\n\n或\n\n```\ngit push origin --delete tag [tagname]\n```\n\n### 清除未跟踪文件\n\n```\ngit clean\n```\n\n可选项：\n\n| 选项                    | 含义                             |\n|-------------------------|----------------------------------|\n| -q, --quiet             | 不显示删除文件名称               |\n| -n, --dry-run           | 试运行                           |\n| -f, --force             | 强制删除                         |\n| -i, --interactive       | 交互式删除                       |\n| -d                      | 删除文件夹                       |\n| -e, --exclude <pattern> | 忽略符合 <pattern> 的文件        |\n| -x                      | 清除包括 .gitignore 里忽略的文件 |\n| -X                      | 只清除 .gitignore 里忽略的文件   |\n\n### 忽略文件属性更改\n\n因为临时需求对某个文件 chmod 了一下，结果这个就被记为了更改，有时候这是想要的，有时候这会造成困扰。\n\n```\ngit config --global core.filemode false\n```\n\n参考：[How do I make Git ignore file mode (chmod) changes?](http://stackoverflow.com/questions/1580596/how-do-i-make-git-ignore-file-mode-chmod-changes)\n\n### patch\n\n将未添加到暂存区的更改生成 patch 文件：\n\n```\ngit diff > demo.patch\n```\n\n将已添加到暂存区的更改生成 patch 文件：\n\n```\ngit diff --cached > demo.patch\n```\n\n合并上面两条命令生成的 patch 文件包含的更改：\n\n```\ngit apply demo.patch\n```\n\n将从 HEAD 之前的 3 次 commit 生成 3 个 patch 文件：\n\n（HEAD 可以换成 sha1 码）\n\n```\ngit format-patch -3 HEAD\n```\n\n生成 af8e2 与 eaf8e 之间的 commits 的 patch 文件：\n\n（注意 af8e2 比 eaf8e 早）\n\n```\ngit format-patch af8e2..eaf8e\n```\n\n合并 format-patch 命令生成的 patch 文件：\n\n```\ngit am 0001-Update.patch\n```\n\n与 `git apply` 不同，这会直接 add 和 commit。\n\n### 只下载最新代码\n\n```\ngit clone --depth 1 git://xxxxxx\n```\n\n这样 clone 出来的仓库会是一个 shallow 的状态，要让它变成一个完整的版本：\n\n```\ngit fetch --unshallow\n```\n\n或\n\n```\ngit pull --unshallow\n```\n\n### 基于某次 commit 创建分支\n\n```sh\ngit checkout -b test 5234ab\n```\n\n表示以 commit hash 为 `5234ab` 的代码为基础创建分支 `test`。\n\n### 恢复单个文件到指定版本\n\n```sh\ngit reset 5234ab MainActivity.java\n```\n\n恢复 MainActivity.java 文件到 commit hash 为 `5234ab` 时的状态。\n\n### 设置全局 hooks\n\n```sh\ngit config --global core.hooksPath C:/Users/mazhuang/git-hooks\n```\n\n然后把对应的 hooks 文件放在最后一个参数指定的目录即可。\n\n比如想要设置在 commit 之前如果检测到没有从服务器同步则不允许 commit，那在以上目录下建立文件 pre-commit，内容如下：\n\n```sh\n#!/bin/sh\n\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\n\ngit fetch origin $CURRENT_BRANCH\n\nHEAD=$(git rev-parse HEAD)\nFETCH_HEAD=$(git rev-parse FETCH_HEAD)\n\nif [ \"$FETCH_HEAD\" = \"$HEAD\" ];\nthen\n    echo \"Pre-commit check passed\"\n    exit 0\nfi\n\necho \"Error: you need to update from remote first\"\n\nexit 1\n```\n\n### 查看某次 commit 的修改内容\n\n```sh\ngit show <commit-hash-id>\n```\n\n### 查看某个文件的修改历史\n\n```sh\ngit log -p <filename>\n```\n\n### 查看最近两次的修改内容\n\n```sh\ngit log -p -2\n```\n\n### 应用已存在的某次更改 / merge 某一个 commit\n\n```sh\ngit cherry-pick <commit-hash-id>\n```\n\ncherry-pick 有更多详细的用法，可以参见帮助文档。\n\n### 命令行自动补全\n\n在 shell 里加载 git-completion 系列脚本，详见 <https://github.com/git/git/tree/master/contrib/completion>\n\n### 文件每一行变更明细\n\n```sh\ngit blame <filename>\n```\n\n### 找回曾经的历史\n\n```sh\ngit reflog\n```\n\n列出 HEAD 曾指向过的一系列 commit，它们只存在于本机，不是版本仓库的一部分。\n\n还有：\n\n```sh\ngit fsck\n```\n\n### 记住 http(s) 方式的用户名密码\n\n在有些情况下无法使用 git 协议，比如公司的 git 服务器设置了 IP 白名单，只能在公司内网使用 ssh，那么在外面就只能使用 http(s) 上传下载源码了，但每次都手动输入用户名/密码特别惨，于是乎就记住吧。\n\n设置记住密码（默认 15 分钟）：\n\n```sh\ngit config --global credential.helper cache\n```\n\n自定义记住的时间（如下面是一小时）：\n\n```sh\ngit config credential.helper 'cache --timeout=3600'\n```\n\n长期存储密码：\n\n```sh\ngit config --global credential.helper store\n```\n\n### git commit 使用 vim 编辑 commit message 中文乱码\n\n这个问题在 Windows 下出现了，没找到能完美解决的办法，一种方法是在 vim 打开后输入：\n\n```sh\n:set termencoding=GBK\n```\n\n这就有点太麻烦了，折衷的方法是改为使用 gVim 或其它你喜欢的编辑器来编辑 commit message：\n\n```sh\ngit config --global core.editor gvim\n```\n\n参考：\n* [How do I make Git use the editor of my choice for commits?](https://stackoverflow.com/questions/2596805/how-do-i-make-git-use-the-editor-of-my-choice-for-commits)\n* [转：git windows中文 乱码问题解决汇总](http://www.cnblogs.com/youxin/p/3227961.html)\n\n### git log 中文乱码\n\n只在 Windows 下遇到。\n\n```sh\ngit config --global i18n.logoutputencoding gbk\n```\n\n编辑 git 安装目录下 etc/profile 文件，在最后添加如下内容：\n\n```\nexport LESSCHARSET=utf-8\n```\n\n参考：[Git for windows 中文乱码解决方案](https://segmentfault.com/a/1190000000578037)\n\n### git diff 中文乱码\n\n只在 Windows 下遇到，目前尚未找到有效办法。\n\n### 统计代码行数\n\nCMD 下直接执行可能失败，可以在右键，Git Bash here 里执行。\n\n#### 统计某人的代码提交量\n\n```sh\ngit log --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"added lines: %s removed lines : %s total lines: %s\\n\",add,subs,loc }'\n```\n\n#### 仓库提交都排名前 5\n\n如果看全部，去掉 head 管道即可。\n\n```sh\ngit log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5\n```\n\n#### 仓库提交者（邮箱）排名前 5\n\n这个统计可能不太准，可能有同名。\n\n```sh\ngit log --pretty=format:%ae | gawk -- '{ ++c[$0]; } END { for(cc in c) printf \"%5d %s\\n\",c[cc],cc; }' | sort -u -n -r | head -n 5\n```\n\n#### 贡献者排名\n\n```sh\ngit log --pretty='%aN' | sort -u | wc -l\n```\n\n#### 提交数统计\n\n```sh\ngit log --oneline | wc -l\n```\n\n参考：[Git代码行统计命令集](http://blog.csdn.net/Dwarven/article/details/46550117)\n\n### 修改文件名时的大小写问题\n\n修改文件名大小写时，默认会被忽略（在 Windows 下是这样），让 git 对大小写敏感的方法：\n\n```sh\ngit config --global core.ignorecase false\n```\n\n或者使用 `git mv oldname newname` 也是可以的。\n","tags":["github"],"categories":["开发语言"]},{"title":"Leetcode#53 最大子序和","url":"/2020/01/20/LeetCode-53/","content":"# 53 最大子序和\n\n## 题目描述\n>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n>示例:\n>\n>输入: [-2,1,-3,4,-1,2,1,-5,4],\n>\n>输出: 6\n>\n>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n>\n>进阶:\n>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n## 分析\n抛开时间限制，最简单的方法就是使用双重循环，分别枚举起止位置，计算累加和，判断是否为最大值并保存。\n\n考虑到时间限制为O(n)时，以上的方法就行不通了，下面介绍几种不通的方法：\n\n### Kadane算法\n此算法是美国卡耐基梅隆大学的教授Kadane发明的，是一种用于求解最大连续子序列和问题的最优算法。对于一个长度为n的数组A而言，从A[0] 到 A[j] 是一个子数组（j < n），那么以A[j]结尾的子数组之最大和，要么是 A[j]， 要么是 max(A[i]~A[j-1])+A[j] ，其中0 ≤ i ≤ j-1。这就是该算法设计的出发点。\n\n```\nclass Solution {\n\tpublic:\n    \n    int maxSubArray(vector<int>& nums) {\n        \n        vector<int>::iterator it  = nums.begin();\n        int maxSum = *it;\n        int theSum = *it;\n        \n        for(it = it+1 ; it != nums.end(); it++){\n            theSum = max(theSum + *it, *it);\n            \n            if(theSum > maxSum)\n                maxSum = theSum;\n        }\n        \n        return maxSum;\n    }\n};\n```\n\n从此想法中，我们可以更近一部得到推论，当A[i-1]<0时，A[i]不变，当A[i-1]>0时，A[i]=A[i]+A[i-1]。因为累加和为负数时，只会减小当前值，所以直接抛弃，当之前的累加和为正数时，会加大当前值，则继续累加。\n\n代码如下:\n\n```\nclass Solution(object):\n    def maxSubArray(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n        for i in range(1, len(nums)):  \n            if nums[i-1] > 0:  \n                nums[i] += nums[i-1]  \n        return max(nums)\n```\n\n### 分治算法\n假设数组下标有效范围是l到r,将数组分为左半部分下标为（l，mid-1）和右半部分下标为(mid+1，r)以及中间元素下标为mid，接下来递归求出左半部分的最大子序和：left=helper(nums,l,mid-1); 右半部分最大子序和right=helper(nums,mid+1,r);\n\n接下来再将左半部分右边界，右半部分左边界以及中间元素nums[mid]整合，用了两个循环，先整合左半部分右边界和中间值，再将整合结果与右半部分左边界整合得到整合以后的最大子序和max_num，最后返回max_num，left,right的最大值即是要求的最大子序和。\n\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {  \n        return divide(nums, 0, nums.size()-1);\n    }  \n    \n    int divide(vector<int>& nums, int l, int r) {\n        if(l == r)  return nums[l];\n        if(l == r-1) return max(nums[l], max(nums[r], nums[l]+nums[r]));\n        \n        int mid = (l+r)>>1;\n        int lret = divide(nums, l, mid-1);\n        int rret = divide(nums, mid+1, r);\n        \n        int mret = nums[mid];\n        int sum = mret;\n        for(int i = mid-1; i >= l ; i --) {\n            sum += nums[i];\n            mret = max(mret, sum);\n        }\n        sum = mret;    //保存已经计算过的左边的最大子序和\n        for(int i = mid+1; i <= r ; i ++) {\n            sum += nums[i];\n            mret = max(mret, sum);\n        }\n        \n        return max(lret, max(rret, mret));\n    }\n};\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"镜头相关名词参数","url":"/2020/01/20/lenses-description/","content":"\n# 镜头(lens)参数\n\n## 焦距(focus)\n镜头的焦距是镜头的一个非常重要的指标。镜头焦距的长短决定了被摄物在成像介质（胶片或CCD等）上成像的大小，也就是相当于物和象的比例尺。当对同一距离的同一个被摄目标拍摄时，镜头焦距长的所成的象大，镜头焦距短的所成的象小。根据用途的不同，照相机镜头的焦距相差非常大，有短到几毫米，十几毫米的，也有长达几米的。\n\n镜头的焦距分为像方焦距和物方焦距。像方焦距是像方主面到象方焦点的距离，同样，物方焦距就是物方主面到物方焦点的距离。必须注意，由于照相机镜头设计，特别是变焦距镜头中广泛采用了望远镜结构，物方焦距与像方焦距是不一定相等的。我们平时说的照相机镜头的焦距是指像方焦距。\n\n焦距通常会清晰显示在镜头上，一般以毫米(mm)表示，定焦镜头只会有一组数字 (如 50mm)，而变焦镜头则会有两组 (如 18-55mm)，说明该支镜头的变焦段(zoom range)。在实际拍摄上，不同的焦距会影响物体在你照片里放到有多大，焦距愈长，物件就放得越大，视角越狭窄，而压缩感较强，景深则越浅。\n\n![](https://i.imgur.com/QwB2tpe.jpg)\n\n以上的变焦镜头焦距为35mm-70mm\n\n下图展示了焦距与视角的关系。\n\n![](https://i.imgur.com/WPclptZ.jpg)\n\n### 超广角镜头与广角镜头\n一般情况下的拍摄用途，少于21mm超广角镜(Ultra wide angle mirror)，用来拍摄广阔风景，21-35mm 广角镜，用来拍摄一般风景\n\n### 定焦镜头与变焦镜头\n大多数视觉系统的工作距离和放大倍数是不变的，因此镜头焦距也是固定的，这样的镜头是定焦镜头，但部分系统需要在工作距离变化后保持放大倍数稳定，或者在工作距离不变的情况下获得不同的放大倍数，这样我们需要选用变焦镜头。\n\n### 标准工业镜头\n对于一般的工业测量、缺陷检测或者定位等，对物体成像的放大倍率没有严格要求，只要选用畸变小的镜头，就可以满足要求\n\n### 远心镜头\n对于精密测量的系统，需要选用远心镜头，它的特点是：物体在景深范围内移动，光学放大倍数不变，这就避免了测试过程中工作距离的轻微改变导致系统放大倍数的变化，保证了系统规定测量精度.\n\n## 靶面\nCCD指的是摄像机里的图像传感器，这个设备是用来把通过镜头进来的图像转化为电子信号.\nCCD靶面尺寸说的就是这个图像传感器的感光部分的大小。一般用英寸来表示，和电视机一样，通常这个数据指的是这个图像传感器的对角长度。常见的靶面有6.35mm (1/4in), 8.47mm (1/3in), 12.7mm (1/2in), 16.9mm (2/3in ),25.4mm (1in)等几种.。这个尺寸的变小只是表示这方面技术也在不断的进步。并不是说1/4英寸就一定比1/3英寸的好，因为不同的场合需要用到一些不同的尺寸所独有的优点。比如1/2英寸可以有比较大的通光量，而1/4英寸可以比较容易的获得大的景深。\n\n## 光圈\n光圈像是一道闸门，用来控制镜头入光量， 曝光 时间一定时，光圈越大，光圈数值越小，入光量越多。另一方面大光圈易拍出浅景深，小光圈容易拍出深景深。 \n\n由于光圈值是以2的倍数变化的，直接用光圈数值表示镜头的通光量，在实际摄影中计算曝光值就会有不少困难。光圈值通常用AV（英文“Aperture Value”的缩写，即“光圈值”）根据圆形的面积与半径的平方值关系，可知为了达到倍数调整通光量的目的，光圈直径应呈√2（约等于1.4）系数关系递增\n\n光圈值（AV）与光圈数值（F）的对应关系见表。\n\n\n光圈值（AV）|0|1|2|3|4|5|6|7|8|9|10\n光圈数值（F）|1|1.4|2|2.8|4|5.6|8|11|16|22|32\n\n光圈英文名称为Aperture，我们平时所说的光圈值F2.8、F8、F16等是光圈“系数”，是相对光圈，并非光圈的物理孔径，与光圈的物理孔径及镜头到感光器件（胶片或CCD或CMOS）的距离有关。\n\n表达光圈大小我们是用F值。光圈F值 = 镜头的焦距/镜头口径的直径，从以上的公式可知要达到相同的光圈F值，长焦距镜头的口径要比短焦距镜头的口径大。当光圈物理孔径不变时，镜头中心与感光器件距离愈远，F数愈大，反之，镜头中心与感光器件距离愈近，通过光孔到达感光器件的光密度愈高，F数就愈小。完整的光圈值系列如下： F1， F1.4， F2， F2.8， F4， F5.6， F8， F11， F16， F22， F32， F44， F64。\n\n这里值得一提的是光圈F值愈小，在同一单位时间内的进光量便愈多，而且上一级的进光量刚是下一级的一倍，例如光圈从F8调整到F5.6，进光量便多一倍，我们也说光圈开大了一级。多数非专业数码相机镜头的焦距短、物理口径很小，F8时光圈的物理孔径已经很小了，继续缩小就会发生衍射之类的光学现象，影响成像。所以一般非专业数码相机的最小光圈都在F8至F11，而专业型数码相机感光器件面积大，镜头距感光器件距离远，物理孔径可以很小，光圈值可以更大。对于消费型数码相机而言，光圈F值常常介于F2.8 - F16。此外许多数码相机在调整光圈时，可以做1/3级的调整。\n\n## 景深\n在光学中，尤其是录影或是摄影，景深 (depth of field,DOF) 是一个描述在空间中，可以清楚成像的距离范围。\n一般会影响到景深长短的原因，有下面三种：\n\n1.光圈越大、景深越短，光圈越小、景深越长\n在拍摄距离不变的拍摄情况下，使用小光圈来拍摄时，因为景深变大，被摄体的前后景物清晰范围会变长。而使用大光圈时，被摄体前后景物清晰的范围就会变短。\n\n2.镜头的焦距越长、景深越短，镜头的焦距越短、景深越长\n在光圈、快门都不变时，拍摄同一个场景，使用长镜头会让景深变浅。而使用广角镜时，景深就会变长。\n左边使用长镜头，右边使用广角镜头，可以看出景深的差异。\n\n3.距离拍摄体越近时、景深越浅，距离拍摄体越远时、景深越长\n在光圈、快门、镜头焦距都不变的情况下，拍摄同一场景，离被摄体越近时，景深就会越浅。离被摄体越远时，景深就会越长。\n一只超广角镜头几乎在所有的光圈下都有极大的景深。一只长焦镜头即使再最小光圈的情况下，景深范围也会非常有限。\n","tags":["机器视觉"],"categories":["个人项目"]},{"title":"OpenCV-Python 手册","url":"/2020/01/20/opencv-python-api/","content":"\nOpenCV Python API手册\n地址：[http://opencv-python-tutroals.readthedocs.io/][1]\n\n[1]: http://opencv-python-tutroals.readthedocs.io/\n","tags":["python"],"categories":["开发语言"]},{"title":"AWS深度学习环境配置","url":"/2020/01/20/AWSDL/","content":"\n# AWS介绍\nAWS即Amazon Web Service，亚马逊云服务。在中国区已经有宁夏和北京两个站点，作为全球最大的云服务提供商，里面的数据我就不吹了。AWS因为提供竞价服务器，所以我们用户可以以比较低的价格租赁GPU服务器，价格大概0.3～0.7 USD 一小时，无论是GCP，阿里云，腾讯云什么的都比这个要贵。由于价格优势，所以很多研究者都是在此租用服务器进行研究的。\n\n# 前期准备\n首先需要有AWS外区账号，国区因为各种问题不提供给个人使用，只面向组织机构使用。其次需要想AWS申请，放开GPU实例的限制（普通账号不可以竞价购买GPU势力，需要申请开通）[参考链接](https://www.cnblogs.com/eniac1946/p/7804212.html)\n\n# 安装具体环境\n由于服务器租赁好之后还需要具体安装深度学习的环境，每次手动安装都十分麻烦，所以在我的github仓库内有我自己写的自动安装脚本，每次服务器租好之后，运行脚本，就可配置完成项目。\n\n","tags":["python","深度学习"],"categories":["环境配置"]},{"title":"深度学习调参方法","url":"/2020/01/20/CNNParameter/","content":"\n# 深度学习神经网络调参方法\n由于深度学习模型每次运行都需要消耗大量时间，所以无目的、无规则地调整模型参数是非常费时费力的。以下是我对神经网络调参方法的整理。\n\n## 可调参数\n\n- learning rate\n\n学习率将影响网络的收敛。太大的学习率容易导致网络不收敛，太小的学习率会使网络收敛速度太慢。\n![](https://i.imgur.com/JyILpQY.png)\n\n- batch_size\n\n本质上batch_size的作用是平衡网络的性能以及计算中内存消耗的变量。通过下图可以看出batch_size的大小对于网络收敛情况的影响。红线代表batch_size为1时模型的收敛情况。蓝线代表batch_size为整个数据集大小时的收敛情况。绿线是batch_size大小在1到整个数据集之间的情况。batch_size通常取[16,128]之间。\n![](https://i.imgur.com/CZIAwh9.png)\n从上图可知，模型对batch_size的大小非常敏感，在调整时需要十分小心。\n\n- epochs\n\n模型在整个数据集上迭代的过程。\n\n- weight initialization\n\n模型中参数的初始化方式。不同的初始化方式有时会对模型结构产生较大的影响。\n\n- regularization\n\n卷积层等的参数正则项，用来控制模型的复杂程度。\n\n- loss function\n\n一般来说分类就是Softmax, 回归就是L2的loss. 但是要注意loss的错误范围(主要是回归), 预测一个label是10000的值, 模型输出0, 你算算这loss多大, 这还是单变量的情况下. 一般结果都是nan. 所以不仅仅输入要做normalization, 输出也要这么弄.+ 多任务情况下, 各loss想法限制在一个量级上, 或者最终限制在一个量级上, 初期可以着重一个任务的loss\n\n\n\n- dropout\n\ndropout参数常设置为0.3,0.5,1\n\n\n## 调参方法\n\n### 可视化激活层结果\n激活层的输出结果应当具有稀疏性和局部性。如果卷积层后的激活层输出的可视化结果和输入图片差不多时，则代表这个卷积并没有学到多少有价值的信息。\n\n### 可视化loss，acc曲线\n\n当网络部分收敛时，可以分为两种情况：欠拟合和过拟合。\n\ntrain set|val test|problem\n:-:|:-:|:-:\nerror small|error too large|overfitting\nerror large|irrelevant|underfitting\nerror small|error small|idea\n\n如果模型出现欠拟合现象，后续参数调整的方向主要是增强模型的拟合能力。例如**增加网络层数，增加节点数，减少dropout值，减少L2正则化，加大batch_size**等。\n\n而针对过拟合现象，则只需要反向操作，如**加大dropout值，使用L2正则化，batch normlization**.\n\n当网络完全不收敛时，可以分为模型错误、数据错误两种。\n\n通常需要对输入值进行正则化，让特征都保持在0均值和1方差。\n\n\n","tags":["深度学习"],"categories":["深度学习"]},{"title":"GDXray数据集介绍","url":"/2020/01/20/GDXray/","content":"\n\n# GDXray数据集介绍\n\n## 数据集概况\nGDXray是一个X-ray综合数据集，共包含19407张图像，整个数据集约3.5GB。数据集包含5种子类别：casting,welds,baggage,natural objects,settings.具体情况如下：\n\n![](https://i.imgur.com/s249NuW.png)\n\n\n## 数据命名规则\n数据集中5种子类的缩写为C,W,B,N,S,每一种子类的命名规则为Xssss，其中X为子类缩写，ssss是子类计数，如baggage中第一种类别为B0001。对于类别中每一张图片采用Xssss_nnnn.png格式，如baggage中第一类的第一张图片名称为B0001_0001.png。\n\n\n","tags":["深度学习","数据集"],"categories":["个人项目"]},{"title":"几种开源协议对比","url":"/2020/01/20/OpenSource/","content":"\n现今存在的开源协议很多，而经过Open Source Initiative组织通过批准的开源协议目前有58种 (http://www.opensource.org/licenses/alphabetical)。\n我们在常见的开源协议如BSD, GPL, LGPL,MIT等都是OSI批准的协议。如果要开源自己的代码，最好也是选择这些被批准的开源协议。\n\n这里我们来看四种最常用的开源协议及它们的适用范围，供那些准备开源或者使用开源产品的开发人员/厂家参考。\n\n# BSD\n\nBSD开源协议（original BSD license、FreeBSD license、Original BSD license）\n\nBSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。\n\n但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：\n\n如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。\n如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。\n不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。\nBSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对 商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。\n\n# Apache Licence \nApache License 2.0（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0）\n\nApache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：\n\n需要给代码的用户一份Apache Licence\n如果你修改了代码，需要再被修改的文件中说明。\n在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。\n如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。\nApache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。\n\n# GPL\nGPL（GNU General Public License）\n\n我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/修改/衍生代码的开源，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。\n\nGPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题。\n\n由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。\n\n其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。\n\n# LGPL \nLGPL（GNU Lesser General Public License）\n\nLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。\n\n但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。\n\nGPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品\n\n# MIT \nMIT（MIT）\n\nMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.\n","tags":["github"],"categories":["开发语言"]},{"title":"PCA:Principal components analysis","url":"/2020/01/20/pca/","content":"\n## 2018年秋季学期知识处理讨论班课件\n \n<br>\n \n \n{% pdf ./pca.pdf %} \n \n \n<br>","tags":["机器学习","课件"],"categories":["课件分享"]}]